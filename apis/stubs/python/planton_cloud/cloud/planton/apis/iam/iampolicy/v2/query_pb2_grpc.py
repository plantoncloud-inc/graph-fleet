# Generated by the gRPC Python protocol compiler plugin. DO NOT EDIT!
"""Client and server classes corresponding to protobuf-defined services."""
import grpc

from cloud.planton.apis.iam.iampolicy.v2 import api_pb2 as cloud_dot_planton_dot_apis_dot_iam_dot_iampolicy_dot_v2_dot_api__pb2
from cloud.planton.apis.iam.iampolicy.v2 import io_pb2 as cloud_dot_planton_dot_apis_dot_iam_dot_iampolicy_dot_v2_dot_io__pb2


class IamPolicyV2QueryControllerStub(object):
    """iam-policy query controller
    """

    def __init__(self, channel):
        """Constructor.

        Args:
            channel: A grpc.Channel.
        """
        self.get = channel.unary_unary(
                '/cloud.planton.apis.iam.iampolicy.v2.IamPolicyV2QueryController/get',
                request_serializer=cloud_dot_planton_dot_apis_dot_iam_dot_iampolicy_dot_v2_dot_io__pb2.IamPolicyId.SerializeToString,
                response_deserializer=cloud_dot_planton_dot_apis_dot_iam_dot_iampolicy_dot_v2_dot_api__pb2.IamPolicy.FromString,
                _registered_method=True)
        self.listResourceAccessByPrincipal = channel.unary_unary(
                '/cloud.planton.apis.iam.iampolicy.v2.IamPolicyV2QueryController/listResourceAccessByPrincipal',
                request_serializer=cloud_dot_planton_dot_apis_dot_iam_dot_iampolicy_dot_v2_dot_io__pb2.ListResourceAccessInput.SerializeToString,
                response_deserializer=cloud_dot_planton_dot_apis_dot_iam_dot_iampolicy_dot_v2_dot_io__pb2.ResourceAccessByPrincipalList.FromString,
                _registered_method=True)
        self.listResourceAccessByRole = channel.unary_unary(
                '/cloud.planton.apis.iam.iampolicy.v2.IamPolicyV2QueryController/listResourceAccessByRole',
                request_serializer=cloud_dot_planton_dot_apis_dot_iam_dot_iampolicy_dot_v2_dot_io__pb2.ListResourceAccessInput.SerializeToString,
                response_deserializer=cloud_dot_planton_dot_apis_dot_iam_dot_iampolicy_dot_v2_dot_io__pb2.ResourceAccessByRoleList.FromString,
                _registered_method=True)
        self.getPrincipalResourceRoles = channel.unary_unary(
                '/cloud.planton.apis.iam.iampolicy.v2.IamPolicyV2QueryController/getPrincipalResourceRoles',
                request_serializer=cloud_dot_planton_dot_apis_dot_iam_dot_iampolicy_dot_v2_dot_io__pb2.PrincipalResourceInput.SerializeToString,
                response_deserializer=cloud_dot_planton_dot_apis_dot_iam_dot_iampolicy_dot_v2_dot_io__pb2.PrincipalResourceRoles.FromString,
                _registered_method=True)
        self.checkAuthorization = channel.unary_unary(
                '/cloud.planton.apis.iam.iampolicy.v2.IamPolicyV2QueryController/checkAuthorization',
                request_serializer=cloud_dot_planton_dot_apis_dot_iam_dot_iampolicy_dot_v2_dot_io__pb2.CheckAuthorizationInput.SerializeToString,
                response_deserializer=cloud_dot_planton_dot_apis_dot_iam_dot_iampolicy_dot_v2_dot_io__pb2.CheckAuthorizationResult.FromString,
                _registered_method=True)
        self.listAuthorizedResourceIds = channel.unary_unary(
                '/cloud.planton.apis.iam.iampolicy.v2.IamPolicyV2QueryController/listAuthorizedResourceIds',
                request_serializer=cloud_dot_planton_dot_apis_dot_iam_dot_iampolicy_dot_v2_dot_io__pb2.ListAuthorizedResourceIdsInput.SerializeToString,
                response_deserializer=cloud_dot_planton_dot_apis_dot_iam_dot_iampolicy_dot_v2_dot_io__pb2.AuthorizedResourceIdsList.FromString,
                _registered_method=True)
        self.listAuthorizedPrincipalIds = channel.unary_unary(
                '/cloud.planton.apis.iam.iampolicy.v2.IamPolicyV2QueryController/listAuthorizedPrincipalIds',
                request_serializer=cloud_dot_planton_dot_apis_dot_iam_dot_iampolicy_dot_v2_dot_io__pb2.ListAuthorizedPrincipalIdsInput.SerializeToString,
                response_deserializer=cloud_dot_planton_dot_apis_dot_iam_dot_iampolicy_dot_v2_dot_io__pb2.AuthorizedPrincipalIdsList.FromString,
                _registered_method=True)
        self.listPrincipals = channel.unary_unary(
                '/cloud.planton.apis.iam.iampolicy.v2.IamPolicyV2QueryController/listPrincipals',
                request_serializer=cloud_dot_planton_dot_apis_dot_iam_dot_iampolicy_dot_v2_dot_io__pb2.ListPrincipalsInput.SerializeToString,
                response_deserializer=cloud_dot_planton_dot_apis_dot_iam_dot_iampolicy_dot_v2_dot_io__pb2.PrincipalAccessList.FromString,
                _registered_method=True)
        self.getPrincipalsCount = channel.unary_unary(
                '/cloud.planton.apis.iam.iampolicy.v2.IamPolicyV2QueryController/getPrincipalsCount',
                request_serializer=cloud_dot_planton_dot_apis_dot_iam_dot_iampolicy_dot_v2_dot_io__pb2.GetPrincipalsCountInput.SerializeToString,
                response_deserializer=cloud_dot_planton_dot_apis_dot_iam_dot_iampolicy_dot_v2_dot_io__pb2.PrincipalsCount.FromString,
                _registered_method=True)


class IamPolicyV2QueryControllerServicer(object):
    """iam-policy query controller
    """

    def get(self, request, context):
        """lookup iam-policy by id
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def listResourceAccessByPrincipal(self, request, context):
        """List all principals and their access grants for a specific resource

        This RPC is designed for UI display of "who has access to this resource".
        It returns a list grouped by principal, showing each principal and all their assigned roles.

        UI Layout:
        The response structure directly maps to a two-column UI layout:
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚ Principal (Left Side)        â”‚ Assigned Roles (Right Side)     â”‚
        â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
        â”‚ ğŸ‘¤ Alice (alice@example.com) â”‚ â€¢ Admin (direct)                â”‚
        â”‚                              â”‚ â€¢ Viewer (inherited from org)   â”‚
        â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
        â”‚ ğŸ‘¥ Engineering Team          â”‚ â€¢ Editor (direct)               â”‚
        â”‚                              â”‚ â€¢ Owner (inherited from org)    â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

        Difference from listResourceAccessByRole:
        - listResourceAccessByPrincipal: Groups by PRINCIPAL â†’ "Alice has [admin, viewer]"
        - listResourceAccessByRole: Groups by ROLE â†’ "Admin role has [Alice, Bob]"

        Inheritance Support:
        When include_inherited=true, the response includes roles inherited from parent resources.
        This shows the complete effective permissions, not just direct assignments.

        Example: User has "admin" on organization â†’ All projects inherit it
        â†’ Querying a project with include_inherited=true shows the user with inherited admin

        Common Use Cases:
        - Organization settings â†’ "Members" tab
        Shows all users/teams with their roles in the organization

        - VPC resource page â†’ "Access" tab
        Shows who can view/edit/delete this specific VPC

        - Environment page â†’ "Sharing" tab
        Shows which users/teams/environments have access

        - Any resource â†’ "Granted Access" view
        Universal pattern for displaying access control across all resources

        When to use this vs listResourceAccessByRole:
        - Use this when answering: "What can Alice do?"
        - Use listResourceAccessByRole when answering: "Who are all the admins?"

        Authorization:
        - Caller must have 'iam_policy_get' permission on the queried resource
        - This ensures users can only see access grants for resources they can view

        Performance:
        - Response size grows with number of principals having access
        - Typically 10-100 principals per resource
        - Includes both users (identity_account) and teams

        Example Request/Response:
        Request:
        resource: {kind: "organization", id: "org-acme-123"}
        include_inherited: false

        Response:
        entries: [
        {
        principal: {kind: "identity_account", id: "ia-alice", name: "Alice", email: "alice@example.com"},
        roles: [
        {
        role: {
        id: "iamr-01HQADMIN",
        code: "admin",
        name: "Administrator",
        description: "Full access to manage all aspects of the resource"
        },
        owner_resource: {kind: "organization", id: "org-acme-123"},
        is_inherited: false
        }
        ]
        },
        {
        principal: {kind: "team", id: "tm-eng", name: "Engineering Team"},
        roles: [
        {
        role: {
        id: "iamr-01HQEDITOR",
        code: "editor",
        name: "Editor",
        description: "Can view and edit, but cannot delete or manage access"
        },
        owner_resource: {kind: "organization", id: "org-acme-123"},
        is_inherited: false
        }
        ]
        }
        ]
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def listResourceAccessByRole(self, request, context):
        """List all role grants and their assigned principals for a specific resource

        This RPC is designed for UI display of "what roles exist on this resource and who has them".
        It returns a list grouped by role, showing each role and all principals assigned to it.

        UI Layout:
        The response structure directly maps to a role-first UI layout:
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚ Role: Administrator                                                  â”‚
        â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
        â”‚ ğŸ‘¤ Alice (alice@example.com) - direct                                â”‚
        â”‚ ğŸ‘¤ Bob (bob@example.com) - inherited from org                        â”‚
        â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
        â”‚ Role: Editor                                                         â”‚
        â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
        â”‚ ğŸ‘¥ Engineering Team - direct                                         â”‚
        â”‚ ğŸ‘¤ Charlie (charlie@example.com) - direct                            â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

        Difference from listResourceAccess:
        - listResourceAccess: Groups by PRINCIPAL â†’ "Alice has [admin, viewer]"
        - listResourceAccessByRole: Groups by ROLE â†’ "Admin role has [Alice, Bob]"

        Use Cases:
        - Organization settings â†’ "Members by Role" view
        Shows separate sections for Admins, Editors, Viewers

        - Compliance/Audit views â†’ "Who has admin access?"
        Quickly see all principals with elevated permissions

        - Resource management â†’ "Permission levels" view
        Groups users by what they can do (full access, edit, view-only)

        When to use this vs listResourceAccess:
        - Use this when answering: "Who are all the admins?"
        - Use listResourceAccess when answering: "What can Alice do?"

        Inheritance Support:
        When include_inherited=true, the response includes roles inherited from parent resources.
        Each principal entry shows whether they have the role directly or through inheritance.

        Example: User has "admin" on organization â†’ All projects inherit it
        â†’ Querying a project with include_inherited=true shows the user under "admin" with inherited flag

        Authorization:
        - Caller must have 'iam_policy_get' permission on the queried resource
        - This ensures users can only see access grants for resources they can view

        Performance:
        - Response size grows with number of roles Ã— number of principals per role
        - Typically 3-10 roles with 5-50 principals each
        - More efficient than listResourceAccess when there are many principals but few roles

        Example Request/Response:
        Request:
        resource: {kind: "organization", id: "org-acme-123"}
        include_inherited: false

        Response:
        entries: [
        {
        role: {
        role: {
        id: "iamr-01HQADMIN",
        code: "admin",
        name: "Administrator",
        description: "Full access to manage all aspects"
        },
        owner_resource: {kind: "organization", id: "org-acme-123"},
        is_inherited: false
        },
        principals: [
        {kind: "identity_account", id: "ia-alice", name: "Alice", email: "alice@example.com"},
        {kind: "identity_account", id: "ia-bob", name: "Bob", email: "bob@example.com"}
        ]
        },
        {
        role: {
        role: {
        id: "iamr-01HQEDITOR",
        code: "editor",
        name: "Editor",
        description: "Can view and edit, but cannot delete"
        },
        owner_resource: {kind: "organization", id: "org-acme-123"},
        is_inherited: false
        },
        principals: [
        {kind: "team", id: "tm-eng", name: "Engineering Team"}
        ]
        }
        ]

        Example with inherited access (include_inherited: true):
        When querying a project that belongs to org-acme-123:
        entries: [
        {
        role: {
        role: {code: "admin", name: "Administrator"},
        owner_resource: {kind: "project", id: "proj-123"},
        is_inherited: false
        },
        principals: [{kind: "identity_account", id: "ia-alice", name: "Alice"}]  // Direct grant on project
        },
        {
        role: {
        role: {code: "admin", name: "Administrator"},
        owner_resource: {kind: "organization", id: "org-acme-123"},
        is_inherited: true
        },
        principals: [{kind: "identity_account", id: "ia-bob", name: "Bob"}]  // Inherited from org
        }
        ]
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def getPrincipalResourceRoles(self, request, context):
        """Get roles assigned to a specific principal on a specific resource

        This RPC answers the question: "What roles does this principal have on this resource?"
        It returns a list of role assignments for the given principal-resource combination.

        Unlike the other access query RPCs (listResourceAccessByPrincipal and listResourceAccessByRole),
        this RPC is targeted and specific:
        - It queries for ONE principal on ONE resource
        - It returns ONLY direct role assignments (no inheritance tracking)
        - It provides simple role information without owner/inheritance metadata

        Difference from other query RPCs:
        - listResourceAccessByPrincipal: Returns ALL principals on a resource â†’ "Who has access?"
        - listResourceAccessByRole: Returns ALL principals grouped by role â†’ "Who are the admins?"
        - getPrincipalResourceRoles: Returns roles for ONE principal â†’ "What can Alice do?"

        Use Cases:
        - User profile page â†’ "Your permissions on this resource"
        Shows what roles the current user has on a specific resource

        - Access verification during operations
        Check if a user has specific roles before performing actions

        - Permission audit trail
        Record what roles a user had on a resource at a specific time

        - Service account validation
        Verify what roles a service account has on infrastructure resources

        - Access request workflows
        Show current user's roles when they request additional access

        Response Characteristics:
        - Only includes DIRECT role assignments (no inherited roles)
        - Returns empty list if principal has no roles on the resource
        - Each role includes: role_id, role_code, role_name, role_description
        - No owner_resource or is_inherited fields (those are not relevant here)

        Authorization:
        - Caller must have 'iam_policy_get' permission on the queried resource
        - This ensures users can only query roles for resources they can view

        Performance:
        - Fast and efficient - queries specific principal-resource pair
        - Typically returns 1-5 roles
        - No inheritance resolution needed

        Example Request/Response:
        Request:
        principal: {kind: "identity_account", id: "ia-alice-123"}
        resource: {kind: "organization", id: "org-acme-456"}

        Response:
        roles: [
        {
        id: "iamr-01HQADMIN",
        code: "admin",
        name: "Administrator",
        description: "Full access to manage all aspects of the organization"
        },
        {
        id: "iamr-01HQVIEWER",
        code: "viewer",
        name: "Viewer",
        description: "Read-only access to view organization details"
        }
        ]

        This tells us that Alice has both admin and viewer roles directly assigned
        on the Acme organization.

        Relationship to V1:
        This RPC is the V2 equivalent of the V1 RPC:
        getByApiResourceKindAndResourceIdAndIdentityAccountId

        The V2 version improves on V1 by:
        - Using structured ApiResourceRef for principal and resource (vs separate kind/id fields)
        - Returning simplified role info without unnecessary inheritance metadata
        - Providing clearer naming that describes the operation
        - Following V2 naming conventions and patterns
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def checkAuthorization(self, request, context):
        """Check if a principal is authorized to perform a relation on a resource

        This is the fundamental authorization check RPC that answers the question:
        "Does principal X have permission Y on resource Z?"

        It provides a simple boolean answer based on the complete authorization state,
        including existing IAM policies, inherited permissions, group memberships,
        and optional contextual policies.

        How It Works:
        The RPC sends the authorization query to OpenFGA, which:
        1. Evaluates the requested policy (principal + resource + relation)
        2. Considers all existing IAM policy grants in the system
        3. Applies inheritance rules (e.g., org admin â†’ project admin)
        4. Evaluates group memberships (e.g., team member â†’ team permissions)
        5. Includes any contextual policies provided (temporary "what-if" scenarios)
        6. Returns true if authorized, false otherwise

        This is NOT a lookup of stored policies - it's a real-time authorization evaluation
        that considers the complete relationship graph and authorization model.

        Use Cases:

        1. Pre-flight UI Checks:
        Before showing a "Delete" button, check if the user can delete the resource
        Input:
        policy: {
        principal: {kind: "identity_account", id: current_user_id},
        resource: {kind: "vpc", id: vpc_id},
        relation: "delete"
        }
        Usage: if (is_authorized) { show_delete_button(); }

        2. API Request Authorization:
        Before processing a sensitive operation, verify the caller has permission
        Input:
        policy: {
        principal: {kind: "identity_account", id: caller_id},
        resource: {kind: "organization", id: org_id},
        relation: "admin"
        }
        Usage: if (!is_authorized) { return PERMISSION_DENIED; }

        3. Service-to-Service Authorization:
        Check if one service can access another service's resources
        Input:
        policy: {
        principal: {kind: "service_account", id: "svc-agent-123"},
        resource: {kind: "aws_credential", id: "cred-prod-456"},
        relation: "use"
        }

        4. Team-based Access Check:
        Check if a user can access a resource through their team membership
        Input:
        policy: {
        principal: {kind: "team", id: "tm-eng-789", relation: "member"},
        resource: {kind: "environment", id: "env-prod-012"},
        relation: "deploy"
        }
        This checks: "Can members of the engineering team deploy to production?"

        5. Dynamic Authorization with Contextual Policies:
        Preview what access a user would have if granted additional permissions
        Input:
        policy: {
        principal: {kind: "identity_account", id: "ia-contractor-345"},
        resource: {kind: "project", id: "proj-client-678"},
        relation: "viewer"
        }
        contextual_policies: [
        {
        principal: {kind: "identity_account", id: "ia-contractor-345"},
        resource: {kind: "team", id: "tm-contractors-901"},
        relation: "member"
        }
        ]
        This checks: "Would contractor have viewer access IF they were a team member?"

        Contextual Policies (Advanced Feature):
        Contextual policies are temporary, hypothetical IAM policies that only exist for
        this specific authorization check. They enable "what-if" scenarios:

        - Access Previews: "Show me what this user could access if I grant them role X"
        - Delegation Testing: "Would this delegation rule work?"
        - Conditional Logic: "Does user have access IF condition Y is true?"
        - Time-based Access: "Grant access during on-call hours"

        Contextual policies are NOT persisted to the database - they only affect this
        single authorization check. This is useful for:
        - UI previews before creating actual policies
        - Dynamic access scenarios that don't need permanent grants
        - Testing authorization rules before deployment

        Example with Contextual Policies:
        Check if Alice can edit a document if she were in the editors team:

        policy: {
        principal: {kind: "identity_account", id: "ia-alice-123"},
        resource: {kind: "document", id: "doc-secret-456"},
        relation: "editor"
        }
        contextual_policies: [
        {
        principal: {kind: "identity_account", id: "ia-alice-123"},
        resource: {kind: "team", id: "tm-editors-789"},
        relation: "member"
        }
        ]

        OpenFGA evaluates: "Alice â†’ member â†’ editors team" AND "editors team â†’ editor â†’ document"
        Result: true if the authorization model allows this relationship chain

        Relationship to Other Query RPCs:

        - checkAuthorization: Checks ONE specific permission (this RPC)
        Question: "Can Alice delete this VPC?"
        Result: boolean (yes/no)

        - getPrincipalResourceRoles: Lists ALL roles a principal has
        Question: "What roles does Alice have on this VPC?"
        Result: list of roles (admin, viewer, etc.)

        - listResourceAccessByPrincipal: Lists ALL principals with access
        Question: "Who can access this VPC?"
        Result: list of users/teams with their roles

        Use checkAuthorization when you need a quick yes/no answer for a specific permission.
        Use the other RPCs when you need to display or audit the complete access picture.

        Authorization Requirements:
        - Caller must have 'iam_policy_get' permission on the resource being checked
        - This ensures users can only check authorization for resources they can view
        - Platform operators can check authorization on any resource

        Performance Characteristics:
        - Fast single-check operation (typically < 50ms)
        - OpenFGA uses optimized graph traversal
        - Contextual policies add minimal overhead
        - Results are NOT cached (always reflects current state)

        Response Interpretation:
        - is_authorized = true: Access granted, proceed with operation
        - is_authorized = false: Access denied, block operation

        Important Notes:
        - This is a point-in-time check - authorization may change if policies are modified
        - A false result doesn't mean the principal has NO access, just not THIS relation
        - For debugging why access was denied, use getPrincipalResourceRoles to see what they DO have
        - This check is read-only and never modifies IAM policies

        Example Request/Response:
        Request:
        policy: {
        principal: {kind: "identity_account", id: "ia-bob-123"},
        resource: {kind: "organization", id: "org-acme-456"},
        relation: "admin"
        }

        Response:
        is_authorized: true

        Interpretation: Bob has admin permission on the Acme organization
        (either through direct grant, inheritance, or group membership)

        Relationship to V1:
        This RPC is the V2 evolution of the V1 checkAuthorization RPC.

        Key improvements in V2:
        - Uses IamPolicySpec instead of FgaTuple (domain language, not OpenFGA terminology)
        - Field names use "policy" and "contextual_policies" (clearer for API consumers)
        - Better documentation with comprehensive use cases
        - Consistent with other V2 API patterns
        - ApiResourceRef structure for principals and resources
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def listAuthorizedResourceIds(self, request, context):
        """List all resource IDs of a specific kind that a principal is authorized to access

        This RPC answers the question: "What are all the [resource-kind] that [principal]
        can [relation] on?" It is the inverse of checkAuthorization:
        - checkAuthorization: Given a principal and ONE resource, does access exist? (boolean)
        - listAuthorizedResourceIds: Given a principal and a RESOURCE KIND, what are ALL accessible IDs? (list)

        The RPC is essential for building permission-aware UIs and filtering resource lists
        to show only what a user can access. Instead of checking each resource individually,
        this efficiently returns all authorized resource IDs in a single query.

        How It Works:
        The RPC queries OpenFGA's ListObjects API, which:
        1. Takes the principal, resource kind, and relation as input
        2. Evaluates all existing IAM policies matching this pattern
        3. Considers inherited permissions from parent resources
        4. Evaluates group memberships (e.g., team member â†’ team permissions)
        5. Includes any contextual policies provided (temporary "what-if" scenarios)
        6. Returns all resource IDs where the principal has the requested relation

        This is an efficient bulk authorization query that leverages OpenFGA's optimized
        graph traversal to find all matching resources without checking each one individually.

        Key Difference from checkAuthorization:
        checkAuthorization checks access to ONE specific resource (needs resource ID as input).
        listAuthorizedResourceIds finds ALL resources of a KIND (no specific ID needed).

        Example Comparison:
        checkAuthorization:
        Input: {principal: Alice, resource: {kind: "vpc", id: "vpc-123"}, relation: "viewer"}
        Output: {is_authorized: true}
        Question: "Can Alice view VPC-123?"

        listAuthorizedResourceIds:
        Input: {principal: Alice, resource_kind: "vpc", relation: "viewer"}
        Output: {resource_ids: ["vpc-123", "vpc-456", "vpc-789"]}
        Question: "Which VPCs can Alice view?"

        Use Cases:

        1. Resource List Filtering (Most Common):
        Show only accessible resources in dropdown lists or table views
        Input:
        principal: {kind: "identity_account", id: current_user_id}
        resource_kind: "vpc"
        relation: "viewer"
        Usage:
        authorized_ids = listAuthorizedResourceIds(...)
        display_vpcs = all_vpcs.filter(id in authorized_ids)

        2. Permission-based Navigation:
        Build navigation menus showing only accessible resources
        Input:
        principal: {kind: "identity_account", id: current_user_id}
        resource_kind: "organization"
        relation: "admin"
        Usage: Show nav items only for organizations where user is admin

        3. Bulk Authorization Checks:
        Efficiently verify access across many resources
        Input:
        principal: {kind: "service_account", id: "svc-agent-123"}
        resource_kind: "aws_credential"
        relation: "use"
        Usage: Find all AWS credentials the agent can use for operations

        4. Team-based Resource Discovery:
        Find resources accessible through team membership
        Input:
        principal: {kind: "team", id: "tm-eng-789", relation: "member"}
        resource_kind: "environment"
        relation: "deploy"
        Usage: "Show all environments that engineering team members can deploy to"

        5. Access Auditing and Reporting:
        Generate reports of what resources a principal can access
        Input:
        principal: {kind: "identity_account", id: "ia-contractor-345"}
        resource_kind: "project"
        relation: "viewer"
        Usage: Audit report: "Contractor X has viewer access to these N projects"

        6. Dynamic Authorization with Contextual Policies:
        Preview what resources would be accessible if additional permissions were granted
        Input:
        principal: {kind: "identity_account", id: "ia-alice-123"}
        resource_kind: "project"
        relation: "viewer"
        contextual_policies: [
        {
        principal: {kind: "identity_account", id: "ia-alice-123"},
        resource: {kind: "team", id: "tm-contractors-901"},
        relation: "member"
        }
        ]
        Usage: "Show Alice what projects she could view IF we add her to the team"

        Contextual Policies (Advanced Feature):
        Like checkAuthorization, this RPC supports contextual policies for "what-if" scenarios.
        These are temporary policies that only exist for this query:

        - Access Previews: "Show what resources user would see if granted role X"
        - Delegation Testing: "What would delegate access through this delegation rule?"
        - Conditional Logic: "What resources are accessible IF condition Y is true?"
        - UI Previews: Preview access changes before actually granting permissions

        Contextual policies enable testing and previewing without modifying actual IAM policies.

        Example with Contextual Policies:
        Preview what projects Alice could access if she joined the contractors team:

        principal: {kind: "identity_account", id: "ia-alice-123"}
        resource_kind: "project"
        relation: "viewer"
        contextual_policies: [
        {
        principal: {kind: "identity_account", id: "ia-alice-123"},
        resource: {kind: "team", id: "tm-contractors-901"},
        relation: "member"
        }
        ]

        OpenFGA evaluates: "Alice â†’ member â†’ contractors team" AND "contractors team â†’ viewer â†’ projects"
        Result: All project IDs accessible through this hypothetical team membership

        Relationship to Other Query RPCs:

        - checkAuthorization: Checks access to ONE specific resource (boolean)
        Question: "Can Alice view VPC-123?"
        Result: true/false

        - listAuthorizedResourceIds: Lists ALL accessible resources of a kind (list)
        Question: "Which VPCs can Alice view?"
        Result: ["vpc-123", "vpc-456", ...]

        - getPrincipalResourceRoles: Lists roles on ONE specific resource (roles list)
        Question: "What roles does Alice have on VPC-123?"
        Result: [admin, viewer]

        - listResourceAccessByPrincipal: Lists ALL principals with access to ONE resource
        Question: "Who can access VPC-123?"
        Result: [Alice, Bob, ...]

        Use listAuthorizedResourceIds for filtering UI lists and bulk access queries.
        Use checkAuthorization for point-in-time access checks on specific resources.

        Authorization Requirements:
        - Caller must be authenticated
        - Platform operators can query for any principal
        - Regular users can query for themselves or teams they manage
        - This is a read-only query operation

        Performance Characteristics:
        - Efficient bulk query using OpenFGA's ListObjects API
        - Performance depends on number of matching resources
        - Typically returns results in < 200ms for most queries
        - Response size: 0-1000+ resource IDs (depends on permissions)
        - Consider pagination for very large result sets in future iterations

        Response Interpretation:
        - Empty list: Principal has no access to any resources of this kind with this relation
        - Non-empty list: Principal is authorized to access all returned resource IDs
        - All returned IDs are guaranteed to pass checkAuthorization with the same inputs

        Important Notes:
        - This is a point-in-time query - authorization may change if policies are modified
        - Results reflect current state plus any contextual policies provided
        - This is read-only and never modifies IAM policies
        - The relation must be valid for the resource_kind (defined in OpenFGA model)
        - Invalid resource_kind or relation will return an empty list
        - For very broad permissions (e.g., org admin), may return large result sets

        Example Request/Response:
        Request:
        principal: {kind: "identity_account", id: "ia-alice-123"}
        resource_kind: "vpc"
        relation: "viewer"

        Response:
        resource_ids: ["vpc-prod-001", "vpc-staging-002", "vpc-dev-003"]

        Interpretation: Alice has viewer permission on these three VPCs.
        You can now:
        - Display these VPCs in the UI
        - Filter VPC lists to only show these
        - Know that checkAuthorization(Alice, any of these VPCs, viewer) = true

        Relationship to V1:
        This RPC is the V2 evolution of the V1 listAuthorizedResourceIds RPC.

        Key improvements in V2:
        - Uses ApiResourceRef for principal (vs separate user_type/user_id/user_relation fields)
        - Clear field naming: "principal", "resource_kind", "relation"
        - Uses IamPolicySpec for contextual_policies (vs FgaTuple for contextual_tuples)
        - Better message naming: AuthorizedResourceIdsList (vs AuthorizedResourceIds)
        - Comprehensive documentation with use cases and examples
        - Consistent with other V2 API patterns and naming conventions
        - Domain language (IAM policies) instead of implementation language (FGA tuples)
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def listAuthorizedPrincipalIds(self, request, context):
        """List all principal IDs of a specific kind that are authorized to access a resource

        This RPC answers the question: "What are all the [principal-kind] that have
        [relation] access on [resource]?" It is the inverse of listAuthorizedResourceIds:
        - listAuthorizedResourceIds: Given a principal and RESOURCE KIND, what are ALL accessible resource IDs?
        - listAuthorizedPrincipalIds: Given a resource and PRINCIPAL KIND, what are ALL authorized principal IDs?

        The RPC is essential for building permission-aware UIs that answer "who has access"
        to a specific resource. Instead of checking each principal individually, this efficiently
        returns all authorized principal IDs of a specific kind in a single query.

        How It Works:
        The RPC queries OpenFGA's ListUsers or ListSubjects API, which:
        1. Takes the resource, principal kind, and relation as input
        2. Evaluates all existing IAM policies matching this pattern
        3. Considers inherited permissions from parent resources
        4. Evaluates group memberships (e.g., users who are team members)
        5. Includes any contextual policies provided (temporary "what-if" scenarios)
        6. Returns all principal IDs of the specified kind that have the requested relation

        This is an efficient bulk query that leverages OpenFGA's optimized graph traversal
        to find all matching principals without checking each one individually.

        Key Difference from listAuthorizedResourceIds:
        listAuthorizedResourceIds finds resources accessible BY a specific principal.
        listAuthorizedPrincipalIds finds principals authorized ON a specific resource.

        Example Comparison:
        listAuthorizedResourceIds:
        Input: {principal: {kind: "identity_account", id: "ia-alice-123"}, resource_kind: "vpc", relation: "viewer"}
        Output: {resource_ids: ["vpc-123", "vpc-456", "vpc-789"]}
        Question: "Which VPCs can Alice view?"

        listAuthorizedPrincipalIds:
        Input: {resource: {kind: "vpc", id: "vpc-123"}, principal_kind: "identity_account", relation: "viewer"}
        Output: {principal_ids: ["ia-alice-123", "ia-bob-456", "ia-charlie-789"]}
        Question: "Which users can view VPC-123?"

        Use Cases:

        1. Resource Access Audit (Most Common):
        Display all users who can access a specific resource
        Input:
        resource: {kind: "vpc", id: "vpc-prod-123"}
        principal_kind: "identity_account"
        relation: "admin"
        Usage:
        principal_ids = listAuthorizedPrincipalIds(...)
        display_section("VPC Administrators", principal_ids)

        2. Team Discovery for Resources:
        Find all teams that have access to a resource
        Input:
        resource: {kind: "environment", id: "env-prod-456"}
        principal_kind: "team"
        relation: "deploy"
        Usage: Show "Teams that can deploy to this environment"

        3. Compliance and Security Audits:
        Generate reports of principals with elevated permissions
        Input:
        resource: {kind: "organization", id: "org-acme-789"}
        principal_kind: "identity_account"
        relation: "owner"
        Usage: Audit report showing all users with owner access

        4. Credential Sharing Views:
        Build "Shared With" lists for credentials and secrets
        Input:
        resource: {kind: "aws_credential", id: "awsc-012"}
        principal_kind: "environment"
        relation: "use"
        Usage: Show "Environments that can use this AWS credential"

        5. Service Account Discovery:
        Find all service accounts with access to infrastructure
        Input:
        resource: {kind: "gcp_credential", id: "gcpc-345"}
        principal_kind: "service_account"
        relation: "use"
        Usage: List service accounts authorized to use this GCP credential

        6. Permission-Level Grouping:
        Display users grouped by their permission level
        Multiple calls with different relations:
        - Call with relation="admin" â†’ Get all admins
        - Call with relation="editor" â†’ Get all editors
        - Call with relation="viewer" â†’ Get all viewers
        Usage: Build multi-section UI showing users by permission level

        7. Dynamic Authorization with Contextual Policies:
        Preview what principals would have access if policies were modified
        Input:
        resource: {kind: "project", id: "proj-678"}
        principal_kind: "identity_account"
        relation: "viewer"
        contextual_policies: [
        {
        principal: {kind: "team", id: "tm-contractors-901"},
        resource: {kind: "project", id: "proj-678"},
        relation: "viewer"
        }
        ]
        Usage: "Which users would have viewer access IF we grant team viewer access?"

        Contextual Policies (Advanced Feature):
        Like other authorization query RPCs, this supports contextual policies for "what-if" scenarios.
        These are temporary policies that only exist for this query:

        - Access Previews: "Show which principals would have access IF we grant role X to team Y"
        - Policy Impact Analysis: "What's the blast radius of granting this permission?"
        - Delegation Testing: "Who would gain access through this delegation rule?"
        - UI Previews: Preview access changes before actually modifying policies

        Contextual policies enable testing and previewing without modifying actual IAM policies.

        Example with Contextual Policies:
        Preview which users would have access if we grant the engineering team viewer access:

        resource: {kind: "vpc", id: "vpc-prod-123"}
        principal_kind: "identity_account"
        relation: "viewer"
        contextual_policies: [
        {
        principal: {kind: "team", id: "tm-eng-456"},
        resource: {kind: "vpc", id: "vpc-prod-123"},
        relation: "viewer"
        }
        ]

        OpenFGA evaluates: All users who are members of tm-eng-456 would have viewer access
        Result: All user IDs who would gain access through this team grant

        Relationship to Other Query RPCs:

        - listAuthorizedResourceIds: Lists ALL resources accessible BY a principal
        Question: "Which VPCs can Alice view?"
        Input: principal (specific), resource_kind, relation
        Output: resource IDs

        - listAuthorizedPrincipalIds: Lists ALL principals authorized ON a resource
        Question: "Which users can view VPC-123?"
        Input: resource (specific), principal_kind, relation
        Output: principal IDs

        - listResourceAccessByPrincipal: Lists ALL principals and their roles on a resource
        Question: "Who has any access to VPC-123 and what are all their roles?"
        Input: resource (specific)
        Output: principals with their full role details (RoleGrant objects)

        - listResourceAccessByRole: Lists ALL principals grouped by role on a resource
        Question: "Show admins, editors, viewers separately"
        Input: resource (specific)
        Output: roles with lists of principals for each

        - checkAuthorization: Checks ONE specific principal on ONE specific resource
        Question: "Can Alice view VPC-123?"
        Input: principal (specific), resource (specific), relation
        Output: boolean

        Use listAuthorizedPrincipalIds when you need:
        - A focused list of principals with a specific permission
        - To filter by principal kind (only users, only teams, etc.)
        - Simple ID list for efficient querying

        Use listResourceAccessByPrincipal when you need:
        - Complete access picture with all principals and all their roles
        - Display information (names, emails, avatars)
        - Role inheritance information

        Authorization Requirements:
        - Caller must have 'iam_policy_get' permission on the queried resource
        - This ensures users can only see who has access to resources they can view
        - Platform operators can query for any resource

        Performance Characteristics:
        - Efficient bulk query using OpenFGA's ListUsers/ListSubjects API
        - Performance depends on number of matching principals
        - Typically returns results in < 200ms for most queries
        - Response size: 0-100 principal IDs for most resources
        - May return 1000+ IDs for organization-level resources with many members
        - Consider pagination in UI for resources with many principals

        Response Interpretation:
        - Empty list: No principals of this kind have the specified relation on the resource
        - Non-empty list: All returned principal IDs have the specified relation on the resource
        - All returned IDs are guaranteed to pass checkAuthorization with the same inputs
        - All IDs are of the principal_kind specified in the input

        Important Notes:
        - This is a point-in-time query - authorization may change if policies are modified
        - Results reflect current state plus any contextual policies provided
        - This is read-only and never modifies IAM policies
        - The relation must be valid for the resource kind (defined in OpenFGA model)
        - The principal_kind must be a valid principal type (identity_account, team, service_account, etc.)
        - Invalid principal_kind or relation will return an empty list
        - For display information (names, emails), fetch principal details using the returned IDs

        Example Request/Response:
        Request:
        resource: {kind: "vpc", id: "vpc-prod-123"}
        principal_kind: "identity_account"
        relation: "admin"

        Response:
        principal_ids: ["ia-alice-001", "ia-bob-002", "ia-charlie-003"]

        Interpretation: Alice, Bob, and Charlie have admin permission on this VPC.
        You can now:
        - Display these users in "VPC Administrators" section
        - Fetch user details for each ID to show names/emails/avatars
        - Filter user dropdowns to only show these authorized admins
        - Know that checkAuthorization(any of these users, vpc-prod-123, admin) = true

        Relationship to V1:
        This RPC is a new addition in V2 and has no direct V1 equivalent.

        V1 had ways to query access but not through a dedicated inverse query RPC.
        The closest V1 equivalent would be querying all IAM policies for a resource
        and then filtering by principal kind and relation, which is inefficient.

        V2 introduces this as the natural complement to listAuthorizedResourceIds,
        providing complete bidirectional query capability:
        - Forward query: principal â†’ resources (listAuthorizedResourceIds)
        - Inverse query: resource â†’ principals (listAuthorizedPrincipalIds)

        This bidirectional design makes authorization queries more intuitive and efficient,
        matching common UI patterns for both "what can I access?" and "who can access this?"
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def listPrincipals(self, request, context):
        """List principals (members or teams) within an organization or environment

        This RPC consolidates V1's separate member and team listing RPCs into a single unified endpoint:
        - V1 RPCs replaced: findMembersByOrg, findMembersByEnv, findTeamsByOrg, findTeamsByEnv
        - V2 approach: Single RPC with principal_kind parameter and optional env (environment slug)

        This RPC answers questions like:
        - "Who are all the members of this organization?"
        - "Which users have access to this environment?"
        - "What teams exist in this organization?"
        - "Which teams can access this environment?"

        Key Features:

        1. Unified Member and Team Listing:
        The principal_kind parameter determines whether to list members or teams:
        - principal_kind = identity_account â†’ Returns individual user members
        - principal_kind = team â†’ Returns teams with team members populated

        2. Organization vs Environment Scope:
        The env parameter determines the scope:
        - env empty â†’ Organization-level principals (roles on org)
        - env provided (with slug) â†’ Environment-level principals (roles on specific env)

        3. Rich Response Data:
        Returns complete principal information for UI display:
        - ApiResourceRefView with name, email, slug, avatar
        - For teams: includes members array with team member details
        - Role assignments with inheritance tracking (direct vs inherited)
        - Pagination metadata (total_pages)

        4. Team Members Display:
        When listing teams (principal_kind = team), each team's ApiResourceRefView
        includes a members field containing all team members with their display info.
        This eliminates the need for separate API calls to fetch team membership.

        Use Cases:

        1. Organization Members Page:
        Display all members of an organization with their roles
        Input:
        org_id: "org-acme-123"
        env: "" (empty)
        principal_kind: identity_account
        page_info: {num: 1, size: 20}
        Response:
        Paginated list of members with roles (admin, viewer, etc.)

        2. Environment Access View:
        Show which users can access a specific environment
        Input:
        org_id: "org-acme-123"
        env: "prod"
        principal_kind: identity_account
        page_info: {num: 1, size: 20}
        Response:
        Members with access to the environment with their roles

        3. Organization Teams Page:
        List all teams in an organization with member details
        Input:
        org_id: "org-acme-123"
        env: "" (empty)
        principal_kind: team
        page_info: {num: 1, size: 20}
        Response:
        Teams with:
        - Team display info (name, avatar)
        - Team members list (nested in ApiResourceRefView.members)
        - Team roles on the organization

        4. Environment Teams View:
        Show which teams have access to a specific environment
        Input:
        org_id: "org-acme-123"
        env: "staging"
        principal_kind: team
        page_info: {num: 1, size: 20}
        Response:
        Teams with environment access, including member lists

        Response Structure:

        For Members (principal_kind = identity_account):
        entries: [
        {
        principal: {
        kind: "identity_account",
        id: "ia-alice-123",
        name: "Alice Smith",
        email: "alice@example.com",
        avatar: "https://...",
        members: []  // Empty for identity accounts
        },
        roles: [
        {
        role: {code: "admin", name: "Administrator"},
        owner_resource: {kind: "organization", id: "org-acme-123"},
        is_inherited: false
        }
        ]
        },
        // ... more members
        ]
        total_pages: 5

        For Teams (principal_kind = team):
        entries: [
        {
        principal: {
        kind: "team",
        id: "tm-eng-456",
        name: "Engineering Team",
        slug: "engineering",
        avatar: "https://...",
        members: [  // Team members populated!
        {
        kind: "identity_account",
        id: "ia-alice-123",
        name: "Alice Smith",
        email: "alice@example.com"
        },
        {
        kind: "identity_account",
        id: "ia-bob-456",
        name: "Bob Jones",
        email: "bob@example.com"
        }
        ]
        },
        roles: [
        {
        role: {code: "admin", name: "Administrator"},
        owner_resource: {kind: "organization", id: "org-acme-123"},
        is_inherited: false
        }
        ]
        },
        // ... more teams
        ]
        total_pages: 2

        Organization vs Environment Behavior:

        Organization-level (env empty):
        - Returns principals with IAM policy grants on the organization resource
        - Roles shown are relative to the organization
        - Example: User with "admin" role on organization

        Environment-level (env provided with slug):
        - Returns principals with IAM policy grants on the environment resource
        - Includes principals with inherited access from organization
        - Roles shown are relative to the environment
        - Example: User with "admin" inherited from org + "viewer" directly on env

        Role Inheritance:

        Each role in the response includes inheritance information:
        - is_inherited = false: Role directly assigned at this level
        - is_inherited = true: Role inherited from parent (org â†’ env)
        - owner_resource: Shows where the role was originally assigned

        Example: User listing for environment with inheritance
        roles: [
        {
        role: {code: "admin"},
        owner_resource: {kind: "organization", id: "org-123"},
        is_inherited: true  // Inherited from org
        },
        {
        role: {code: "viewer"},
        owner_resource: {kind: "environment", id: "env-456"},
        is_inherited: false  // Direct grant on env
        }
        ]

        Pagination:

        The RPC supports pagination via PageInfo:
        - page_info.num: Page number (1-based)
        - page_info.size: Items per page

        Response includes:
        - entries: Current page of results
        - total_pages: Total number of pages available

        UI can calculate:
        - Has next page: current_page < total_pages
        - Has previous page: current_page > 1

        Authorization:

        Caller must have organization-level permissions:
        - For org-level queries: Must have 'get' permission on the organization
        - For env-level queries: Must have 'get' permission on the organization
        (environment access control is inherited from organization)

        Authorization is checked via RPC authorization middleware:
        - resource_kind: organization
        - permission: get
        - field_path: "org_id"

        This ensures only authorized users can list members/teams.

        Performance Considerations:

        - Response size grows with number of principals per page
        - For teams: includes nested member data (adds to response size)
        - Typical response: 10-50 principals per page
        - Recommended page_size: 20-50 for good balance
        - For large organizations (1000+ members): use pagination

        Relationship to V1 RPCs:

        This single V2 RPC replaces 4 separate V1 RPCs:

        V1 â†’ V2 Mapping:
        - findMembersByOrg â†’ listPrincipals(org_id, env="", principal_kind=identity_account)
        - findMembersByEnv â†’ listPrincipals(org_id, env="prod", principal_kind=identity_account)
        - findTeamsByOrg â†’ listPrincipals(org_id, env="", principal_kind=team)
        - findTeamsByEnv â†’ listPrincipals(org_id, env="prod", principal_kind=team)

        V2 Improvements:
        - Single RPC reduces API surface area
        - Consistent request/response structure
        - Better pagination support
        - Team members included in response (no extra calls)
        - Enhanced inheritance tracking
        - Richer display information (avatar, slug)

        Example Requests:

        1. List first page of org members:
        {
        org_id: "org-acme-123",
        env: "",
        principal_kind: identity_account,
        page_info: {num: 1, size: 20}
        }

        2. List second page of environment members:
        {
        org_id: "org-acme-123",
        env: "prod",
        principal_kind: identity_account,
        page_info: {num: 2, size: 20}
        }

        3. List org teams with 50 per page:
        {
        org_id: "org-acme-123",
        env: "",
        principal_kind: team,
        page_info: {num: 1, size: 50}
        }
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def getPrincipalsCount(self, request, context):
        """Get count of principals (members or teams) within an organization or environment

        This RPC consolidates V1's separate member and team count RPCs into a single unified endpoint:
        - V1 RPCs replaced: getMembersCountByOrg, getMembersCountByEnv, getTeamsCountByOrg, getTeamsCountByEnv
        - V2 approach: Single RPC with principal_kind parameter and optional env (environment slug)

        This RPC answers questions like:
        - "How many members are in this organization?"
        - "How many users have access to this environment?"
        - "How many teams exist in this organization?"
        - "How many teams can access this environment?"

        Key Features:

        1. Unified Member and Team Counting:
        The principal_kind parameter determines what to count:
        - principal_kind = identity_account â†’ Count individual user members
        - principal_kind = team â†’ Count teams

        2. Organization vs Environment Scope:
        The env parameter determines the scope:
        - env empty â†’ Count organization-level principals
        - env provided (with slug) â†’ Count environment-level principals

        3. Efficient Count-Only Operation:
        Returns only the count without fetching full principal details:
        - No pagination needed (single count value)
        - No role information included
        - Fast query optimized for counting

        Use Cases:

        1. Organization Header Statistics:
        Display "145 members" in organization dashboard
        Input:
        org_id: "org-acme-123"
        env: "" (empty)
        principal_kind: identity_account
        Response:
        {count: 145}

        2. Environment Access Summary:
        Show "23 users have access" on environment page
        Input:
        org_id: "org-acme-123"
        env: "prod"
        principal_kind: identity_account
        Response:
        {count: 23}

        3. Team Management Overview:
        Display "12 teams" in organization settings
        Input:
        org_id: "org-acme-123"
        env: "" (empty)
        principal_kind: team
        Response:
        {count: 12}

        4. Environment Team Access:
        Show "5 teams can deploy" on environment page
        Input:
        org_id: "org-acme-123"
        env: "staging"
        principal_kind: team
        Response:
        {count: 5}

        5. Pagination Calculation:
        Calculate total pages for listPrincipals pagination
        Input:
        org_id: "org-acme-123"
        env: ""
        principal_kind: identity_account
        Response:
        {count: 145}
        Calculation:
        total_pages = ceil(145 / page_size)

        Response Structure:

        Simple count response:
        {
        count: 42
        }

        Count values:
        - Always >= 0
        - 0 means no principals found (not an error condition)
        - Includes all principals matching the criteria:
        - For org-level: principals with roles on the organization
        - For env-level: principals with roles on the environment (including inherited)

        Organization vs Environment Behavior:

        Organization-level (env empty):
        - Counts principals with IAM policy grants on the organization
        - Example: Count all users who are organization members

        Environment-level (env provided with slug):
        - Counts principals with IAM policy grants on the environment
        - Includes principals with inherited access from organization
        - Example: Count all users who can access the environment
        (either directly or through org membership)

        Counting Logic:

        The count reflects the same principals that would be returned by listPrincipals
        with the same parameters (org_id, env, principal_kind).

        - Each unique principal is counted once
        - Principals with multiple roles are counted once
        - For env-level counts: inherited principals are included

        Example: If a user has both "admin" (inherited from org) and "viewer" (direct on env),
        they are counted once in the environment count.

        Authorization:

        Caller must have organization-level permissions:
        - For org-level counts: Must have 'get' permission on the organization
        - For env-level counts: Must have 'get' permission on the organization
        (environment access control is inherited from organization)

        Authorization is checked via RPC authorization middleware:
        - resource_kind: organization
        - permission: get
        - field_path: "org_id"

        This ensures only authorized users can get principal counts.

        Performance Considerations:

        - Fast count-only query (no data fetching overhead)
        - Optimized database query using COUNT() aggregation
        - Typically < 50ms response time
        - Response size: minimal (single integer)
        - Suitable for frequent polling (dashboard updates)

        Relationship to V1 RPCs:

        This single V2 RPC replaces 4 separate V1 RPCs:

        V1 â†’ V2 Mapping:
        - getMembersCountByOrg â†’ getPrincipalsCount(org_id, env="", principal_kind=identity_account)
        - getMembersCountByEnv â†’ getPrincipalsCount(org_id, env="prod", principal_kind=identity_account)
        - getTeamsCountByOrg â†’ getPrincipalsCount(org_id, env="", principal_kind=team)
        - getTeamsCountByEnv â†’ getPrincipalsCount(org_id, env="prod", principal_kind=team)

        V2 Improvements:
        - Single RPC reduces API surface area
        - Consistent request/response structure
        - Simpler mental model (one RPC for counting)
        - Same filtering logic as listPrincipals (consistency)

        Relationship to listPrincipals:

        These two RPCs are designed to work together:

        1. Get count for pagination setup:
        count = getPrincipalsCount(org_id, env, principal_kind)
        total_pages = ceil(count / page_size)

        2. Fetch paginated data:
        data = listPrincipals(org_id, env, principal_kind, page_info)

        The count matches the total number of principals that listPrincipals
        would return across all pages with the same parameters.

        Example Requests:

        1. Count org members:
        {
        org_id: "org-acme-123",
        env: "",
        principal_kind: identity_account
        }
        â†’ Response: {count: 145}

        2. Count environment members:
        {
        org_id: "org-acme-123",
        env: "prod",
        principal_kind: identity_account
        }
        â†’ Response: {count: 23}

        3. Count org teams:
        {
        org_id: "org-acme-123",
        env: "",
        principal_kind: team
        }
        â†’ Response: {count: 12}

        4. Count environment teams:
        {
        org_id: "org-acme-123",
        env: "staging",
        principal_kind: team
        }
        â†’ Response: {count: 5}
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')


def add_IamPolicyV2QueryControllerServicer_to_server(servicer, server):
    rpc_method_handlers = {
            'get': grpc.unary_unary_rpc_method_handler(
                    servicer.get,
                    request_deserializer=cloud_dot_planton_dot_apis_dot_iam_dot_iampolicy_dot_v2_dot_io__pb2.IamPolicyId.FromString,
                    response_serializer=cloud_dot_planton_dot_apis_dot_iam_dot_iampolicy_dot_v2_dot_api__pb2.IamPolicy.SerializeToString,
            ),
            'listResourceAccessByPrincipal': grpc.unary_unary_rpc_method_handler(
                    servicer.listResourceAccessByPrincipal,
                    request_deserializer=cloud_dot_planton_dot_apis_dot_iam_dot_iampolicy_dot_v2_dot_io__pb2.ListResourceAccessInput.FromString,
                    response_serializer=cloud_dot_planton_dot_apis_dot_iam_dot_iampolicy_dot_v2_dot_io__pb2.ResourceAccessByPrincipalList.SerializeToString,
            ),
            'listResourceAccessByRole': grpc.unary_unary_rpc_method_handler(
                    servicer.listResourceAccessByRole,
                    request_deserializer=cloud_dot_planton_dot_apis_dot_iam_dot_iampolicy_dot_v2_dot_io__pb2.ListResourceAccessInput.FromString,
                    response_serializer=cloud_dot_planton_dot_apis_dot_iam_dot_iampolicy_dot_v2_dot_io__pb2.ResourceAccessByRoleList.SerializeToString,
            ),
            'getPrincipalResourceRoles': grpc.unary_unary_rpc_method_handler(
                    servicer.getPrincipalResourceRoles,
                    request_deserializer=cloud_dot_planton_dot_apis_dot_iam_dot_iampolicy_dot_v2_dot_io__pb2.PrincipalResourceInput.FromString,
                    response_serializer=cloud_dot_planton_dot_apis_dot_iam_dot_iampolicy_dot_v2_dot_io__pb2.PrincipalResourceRoles.SerializeToString,
            ),
            'checkAuthorization': grpc.unary_unary_rpc_method_handler(
                    servicer.checkAuthorization,
                    request_deserializer=cloud_dot_planton_dot_apis_dot_iam_dot_iampolicy_dot_v2_dot_io__pb2.CheckAuthorizationInput.FromString,
                    response_serializer=cloud_dot_planton_dot_apis_dot_iam_dot_iampolicy_dot_v2_dot_io__pb2.CheckAuthorizationResult.SerializeToString,
            ),
            'listAuthorizedResourceIds': grpc.unary_unary_rpc_method_handler(
                    servicer.listAuthorizedResourceIds,
                    request_deserializer=cloud_dot_planton_dot_apis_dot_iam_dot_iampolicy_dot_v2_dot_io__pb2.ListAuthorizedResourceIdsInput.FromString,
                    response_serializer=cloud_dot_planton_dot_apis_dot_iam_dot_iampolicy_dot_v2_dot_io__pb2.AuthorizedResourceIdsList.SerializeToString,
            ),
            'listAuthorizedPrincipalIds': grpc.unary_unary_rpc_method_handler(
                    servicer.listAuthorizedPrincipalIds,
                    request_deserializer=cloud_dot_planton_dot_apis_dot_iam_dot_iampolicy_dot_v2_dot_io__pb2.ListAuthorizedPrincipalIdsInput.FromString,
                    response_serializer=cloud_dot_planton_dot_apis_dot_iam_dot_iampolicy_dot_v2_dot_io__pb2.AuthorizedPrincipalIdsList.SerializeToString,
            ),
            'listPrincipals': grpc.unary_unary_rpc_method_handler(
                    servicer.listPrincipals,
                    request_deserializer=cloud_dot_planton_dot_apis_dot_iam_dot_iampolicy_dot_v2_dot_io__pb2.ListPrincipalsInput.FromString,
                    response_serializer=cloud_dot_planton_dot_apis_dot_iam_dot_iampolicy_dot_v2_dot_io__pb2.PrincipalAccessList.SerializeToString,
            ),
            'getPrincipalsCount': grpc.unary_unary_rpc_method_handler(
                    servicer.getPrincipalsCount,
                    request_deserializer=cloud_dot_planton_dot_apis_dot_iam_dot_iampolicy_dot_v2_dot_io__pb2.GetPrincipalsCountInput.FromString,
                    response_serializer=cloud_dot_planton_dot_apis_dot_iam_dot_iampolicy_dot_v2_dot_io__pb2.PrincipalsCount.SerializeToString,
            ),
    }
    generic_handler = grpc.method_handlers_generic_handler(
            'cloud.planton.apis.iam.iampolicy.v2.IamPolicyV2QueryController', rpc_method_handlers)
    server.add_generic_rpc_handlers((generic_handler,))
    server.add_registered_method_handlers('cloud.planton.apis.iam.iampolicy.v2.IamPolicyV2QueryController', rpc_method_handlers)


 # This class is part of an EXPERIMENTAL API.
class IamPolicyV2QueryController(object):
    """iam-policy query controller
    """

    @staticmethod
    def get(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/cloud.planton.apis.iam.iampolicy.v2.IamPolicyV2QueryController/get',
            cloud_dot_planton_dot_apis_dot_iam_dot_iampolicy_dot_v2_dot_io__pb2.IamPolicyId.SerializeToString,
            cloud_dot_planton_dot_apis_dot_iam_dot_iampolicy_dot_v2_dot_api__pb2.IamPolicy.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def listResourceAccessByPrincipal(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/cloud.planton.apis.iam.iampolicy.v2.IamPolicyV2QueryController/listResourceAccessByPrincipal',
            cloud_dot_planton_dot_apis_dot_iam_dot_iampolicy_dot_v2_dot_io__pb2.ListResourceAccessInput.SerializeToString,
            cloud_dot_planton_dot_apis_dot_iam_dot_iampolicy_dot_v2_dot_io__pb2.ResourceAccessByPrincipalList.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def listResourceAccessByRole(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/cloud.planton.apis.iam.iampolicy.v2.IamPolicyV2QueryController/listResourceAccessByRole',
            cloud_dot_planton_dot_apis_dot_iam_dot_iampolicy_dot_v2_dot_io__pb2.ListResourceAccessInput.SerializeToString,
            cloud_dot_planton_dot_apis_dot_iam_dot_iampolicy_dot_v2_dot_io__pb2.ResourceAccessByRoleList.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def getPrincipalResourceRoles(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/cloud.planton.apis.iam.iampolicy.v2.IamPolicyV2QueryController/getPrincipalResourceRoles',
            cloud_dot_planton_dot_apis_dot_iam_dot_iampolicy_dot_v2_dot_io__pb2.PrincipalResourceInput.SerializeToString,
            cloud_dot_planton_dot_apis_dot_iam_dot_iampolicy_dot_v2_dot_io__pb2.PrincipalResourceRoles.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def checkAuthorization(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/cloud.planton.apis.iam.iampolicy.v2.IamPolicyV2QueryController/checkAuthorization',
            cloud_dot_planton_dot_apis_dot_iam_dot_iampolicy_dot_v2_dot_io__pb2.CheckAuthorizationInput.SerializeToString,
            cloud_dot_planton_dot_apis_dot_iam_dot_iampolicy_dot_v2_dot_io__pb2.CheckAuthorizationResult.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def listAuthorizedResourceIds(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/cloud.planton.apis.iam.iampolicy.v2.IamPolicyV2QueryController/listAuthorizedResourceIds',
            cloud_dot_planton_dot_apis_dot_iam_dot_iampolicy_dot_v2_dot_io__pb2.ListAuthorizedResourceIdsInput.SerializeToString,
            cloud_dot_planton_dot_apis_dot_iam_dot_iampolicy_dot_v2_dot_io__pb2.AuthorizedResourceIdsList.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def listAuthorizedPrincipalIds(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/cloud.planton.apis.iam.iampolicy.v2.IamPolicyV2QueryController/listAuthorizedPrincipalIds',
            cloud_dot_planton_dot_apis_dot_iam_dot_iampolicy_dot_v2_dot_io__pb2.ListAuthorizedPrincipalIdsInput.SerializeToString,
            cloud_dot_planton_dot_apis_dot_iam_dot_iampolicy_dot_v2_dot_io__pb2.AuthorizedPrincipalIdsList.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def listPrincipals(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/cloud.planton.apis.iam.iampolicy.v2.IamPolicyV2QueryController/listPrincipals',
            cloud_dot_planton_dot_apis_dot_iam_dot_iampolicy_dot_v2_dot_io__pb2.ListPrincipalsInput.SerializeToString,
            cloud_dot_planton_dot_apis_dot_iam_dot_iampolicy_dot_v2_dot_io__pb2.PrincipalAccessList.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def getPrincipalsCount(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/cloud.planton.apis.iam.iampolicy.v2.IamPolicyV2QueryController/getPrincipalsCount',
            cloud_dot_planton_dot_apis_dot_iam_dot_iampolicy_dot_v2_dot_io__pb2.GetPrincipalsCountInput.SerializeToString,
            cloud_dot_planton_dot_apis_dot_iam_dot_iampolicy_dot_v2_dot_io__pb2.PrincipalsCount.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)
